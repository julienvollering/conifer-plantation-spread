---
title: "Dispersal model validation"
output: html_document 
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(here)
library(sf)
```

```{r read seed sources and traps}
sources <- read_csv(here("data","raw","seedtraps","seedsources.csv")) %>% 
  st_as_sf(coords = c(1:2), crs = 25832) # ETRS89 / UTM zone 32N
plot(sources["height"], key.pos = 4)
plot(sources["cones"], key.pos = 4)
hist(sources$cones)

traps <- read_csv(here("data","raw","seedtraps","seedtraps.csv")) %>% 
  st_as_sf(coords = c(1:2), crs = 25832) # ETRS89 / UTM zone 32N
plot(traps["seeds"], key.pos = 4)
hist(traps$seeds, 20)
```

```{r make grid geometry}
gridres <- 2
datageom <- c(st_geometry(sources), st_geometry(traps))
grd <- st_sf(st_make_grid(datageom, cellsize = gridres, 
                          offset = floor(st_bbox(datageom)[c("xmin", "ymin")])))
pts <- st_sf(st_make_grid(datageom, cellsize = gridres,
                          offset = floor(st_bbox(datageom)[c("xmin", "ymin")]),
                          what = "centers"))
bb <- st_bbox(grd)
nx <- unname((bb$xmax - bb$xmin)/gridres)
ny <- unname((bb$ymax - bb$ymin)/gridres)
paste(nx, "x", ny)

ras <- raster::raster(nrows=ny, ncols=nx, 
                      xmn=st_bbox(grd)[1], xmx=st_bbox(grd)[3], 
                      ymn=st_bbox(grd)[2], ymx=st_bbox(grd)[4],
                      crs=st_crs(grd)$proj4string)
```

```{r add data to geometry}
landscape <- raster::raster(here("data","raw","seedtraps","lidar","vegheight.tif")) %>% 
  raster::extract(as(pts, "Spatial")) %>% 
  st_sf(geometry = st_geometry(pts)) 
colnames(landscape)[1] <- "vegheight"
landscape$vegheight[(is.na(landscape$vegheight))] <- 0 
```

```{r wind Floro station, warning=FALSE, eval=FALSE, include=FALSE}
windobs <- read_delim(here("data","raw","eKlima","obswind-stnr57710FLORO-20190604.txt"), 
                      delim = ";", na = "-9999", skip = 24) %>% 
  drop_na()
count(windobs, fDD)
count(windobs, fFF)
windobs <- filter(windobs, fDD == "OK" & fFF == "OK") %>% 
  select(-c("St.no", "fDD", "fFF"))

windobs %>% 
  group_by(Mnth) %>% 
  summarize(mean=mean(FF), sd=sd(FF))
```

```{r wind NORA10-BC}
poi <- read_csv(here("data","raw","NORA10","poi-lonlat.csv"))
poi <- mutate(poi, site = 1:nrow(poi)) %>% 
  st_as_sf(coords=c("X", "Y"))
plot(poi)

DD <- read_delim(here("data","raw","NORA10","nora10bc.WindDir.txt"), delim = ";") %>% 
  filter(SITE == 1)
FF <- read_delim(here("data","raw","NORA10","nora10bc.WindSpeed.txt"), delim = ";") %>% 
  filter(SITE == 1) %>% 
  select(-SITE)
NORAwind <- left_join(DD, FF, by = "TIME") %>% 
  rename(DD = WD, FF = WS) %>% 
  mutate(TIME = as.character(TIME)) %>% 
  mutate(Mnth = substring(TIME, 5, 6)) %>% 
  drop_na()

windobs <- NORAwind
```

```{r abscission-dependent WALD model, cache=TRUE}
freeze <- ls()
source(here("R","dispersal-functions.R"))
source(here("R","SkarpaasShea_2007.R"))

terminal.velocity <- 0.94 # m/s, after Sandvik, H. 2012.
sector.breaks <- seq(0, 360, by=10)
dispersal.season <- c(9:12,1:2) # after Harris, A. S. 1990.
windobs <- windobs %>% 
  filter(Mnth %in% dispersal.season) %>% 
  mutate(sector = cut(DD, sector.breaks, include.lowest = TRUE))

# Assume probability of abscission is directly related to wind speed
set.seed(42)
sectors360 <- tibble(sector = unique(cut(0:360, sector.breaks, include.lowest = TRUE))) %>% 
  add_column(weight = sample_frequency(among = windobs, of = quo(sector), weightedby = quo(FF)))
set.seed(42)
winds <- lapply(sectors360$sector, function(x) {
  filter(windobs, sector == x) %>% 
    sample_n(100, replace = TRUE, weight = FF) %>% 
    pull(FF)
})

pb <- txtProgressBar(0, nrow(sources), style = 3)

src.arr <- array(dim = c(nx, ny, nrow(sources)))

for (i in seq_along(sources$geometry)) { # i <- 1
  landscape$sector <- assign_sectors(to = landscape, around = sources[i, ], 
                            between = sector.breaks)
  landscape$distance <- as.numeric(st_distance(landscape, sources[i,]))
  src.sectors <- sectors360$sector[sectors360$sector %in% landscape$sector]
  
  sec.arr <- array(dim = c(nx, ny, length(src.sectors)))
  
  for (j in seq_along(src.sectors)) { # j <- 1

    vegheight <- landscape %>% 
      filter(sector == src.sectors[j]) %>% 
      pull(vegheight) %>% 
      mean()
    distances <- landscape$distance
    distances[landscape$sector != src.sectors[j]] <- NA
    
    wind.arr <- array(data = NA, dim = c(nx, ny, 100))
    
    for (k in 1:100) { # k <- 1
      WALD <- parameterize_WALD(H = pull(sources[i,], "height"), 
                                Fm = terminal.velocity,
                                Um = winds[[j]][k], zm = 10, # measured 10 m above ground at station 
                                h = vegheight)
      
      # Divisor below accounts for the fact that the WALD formulation used here (inverse gaussian dist) is the "dispersal DISTANCE kernel" (eq. 15.3 Nathan et al. 2012). 
      # 2πr reduces the probability density by spreading it across a 2D ring
      # nrow(sectors360) further reduces the probability density because we take only a fraction of the 2D ring (an arc)
      # Essentially, far cells are reduced relative to close cells, because the distance kernel is spread over a longer arc at distance.
      wind.arr[, , k] <- WALD(distances) / (2*pi*distances*nrow(sectors360))
    }
    sec.arr[, , j] <- sum_third_dim(wind.arr)
  }
  src.arr[, , i] <- sum_third_dim(sec.arr, 
                                  sectors360$weight[which(sectors360$sector %in% src.sectors)])
  setTxtProgressBar(pb, i)
}      
close(pb)

saveRDS(src.arr, here("output","broervika","WALD-absdep_src-arr.rds"))      
# src.arr <- readRDS(here("output","broervika","WALD-absdep_src-arr.rds"))

src.mat <- sum_third_dim(src.arr, sources$cones)

grd[, "density"] <- src.mat[1:length(src.mat)]
ras <- raster::rasterize(as(grd, "Spatial"), ras, field="density")
raster::writeRaster(ras, here("output","broervika","adWALD.tif"))

raster::plot(log(ras), main = "log(abscission-dependent WALD)", col = viridis::viridis(n=255))
points(as(sources, "Spatial"))
points(as(traps, "Spatial"), pch=20, col="red")

rm(list = setdiff(ls(), c(freeze)))
```

```{r abscission-independent WALD model, cache=TRUE}
freeze <- ls()
source(here("R","dispersal-functions.R"))
source(here("R","SkarpaasShea_2007.R"))

terminal.velocity <- 0.94 # m/s, after Sandvik, H. 2012.
sector.breaks <- seq(0, 360, by=10)
dispersal.season <- c(9:12,1:2) # after Harris, A. S. 1990.
windobs <- windobs %>% 
  filter(Mnth %in% dispersal.season) %>% 
  mutate(sector = cut(DD, sector.breaks, include.lowest = TRUE))

# Assume probability of abscission is UNRELATED to wind speed (constant)
set.seed(42)
sectors360 <- tibble(sector = unique(cut(0:360, sector.breaks, include.lowest = TRUE))) %>% 
  add_column(weight = sample_frequency(among = windobs, of = quo(sector), weightedby = NULL))
set.seed(42)
winds <- lapply(sectors360$sector, function(x) {
  filter(windobs, sector == x) %>% 
    sample_n(100, replace = TRUE, weight = NULL) %>% 
    pull(FF)
})

pb <- txtProgressBar(0, nrow(sources), style = 3)

src.arr <- array(dim = c(nx, ny, nrow(sources)))

for (i in seq_along(sources$geometry)) { # i <- 1
  landscape$sector <- assign_sectors(to = landscape, around = sources[i, ], 
                            between = sector.breaks)
  landscape$distance <- as.numeric(st_distance(landscape, sources[i,]))
  src.sectors <- sectors360$sector[sectors360$sector %in% landscape$sector]
  
  sec.arr <- array(dim = c(nx, ny, length(src.sectors)))
  
  for (j in seq_along(src.sectors)) { # j <- 1

    vegheight <- landscape %>% 
      filter(sector == src.sectors[j]) %>% 
      pull(vegheight) %>% 
      mean()
    distances <- landscape$distance
    distances[landscape$sector != src.sectors[j]] <- NA
    
    wind.arr <- array(data = NA, dim = c(nx, ny, 100))
    
    for (k in 1:100) { # k <- 1
      WALD <- parameterize_WALD(H = pull(sources[i,], "height"), 
                                Fm = terminal.velocity,
                                Um = winds[[j]][k], zm = 10, # measured 10 m above ground at station 
                                h = vegheight)
      
      # Divisor below accounts for the fact that the WALD formulation used here (inverse gaussian dist) is the "dispersal DISTANCE kernel" (eq. 15.3 Nathan et al. 2012). 
      # 2πr reduces the probability density by spreading it across a 2D ring
      # nrow(sectors360) further reduces the probability density because we take only a fraction of the 2D ring (an arc)
      # Essentially, far cells are reduced relative to close cells, because the distance kernel is spread over a longer arc at distance.
      wind.arr[, , k] <- WALD(distances) / (2*pi*distances*nrow(sectors360))
    }
    sec.arr[, , j] <- sum_third_dim(wind.arr)
  }
  src.arr[, , i] <- sum_third_dim(sec.arr, 
                                  sectors360$weight[which(sectors360$sector %in% src.sectors)])
  setTxtProgressBar(pb, i)
}      
close(pb)

saveRDS(src.arr, here("output","broervika","WALD-absind_src-arr.rds"))      
# src.arr <- readRDS(here("output","broervika","WALD-absind_src-arr.rds"))

src.mat <- sum_third_dim(src.arr, sources$cones)

grd[, "density"] <- src.mat[1:length(src.mat)]
ras <- raster::rasterize(as(grd, "Spatial"), ras, field="density")
raster::writeRaster(ras, here("output","broervika","aiWALD.tif"))

raster::plot(log(ras), main = "log(abscission-independent WALD)", col = viridis::viridis(n=255))
points(as(sources, "Spatial"))
points(as(traps, "Spatial"), pch=20, col="red")

rm(list = setdiff(ls(), c(freeze)))
```

```{r generalized Exponential Power model}
freeze <- ls()
source(here("R","dispersal-functions.R"))

# From Bullock et al. 2017
a <- 2.7825
b <- 0.8346
exp_power <- function(d) {
  b*(2*pi*a^2*gamma(2/b))^-1*exp(-(d^b/a^b))
}

src.arr <- array(dim = c(nx, ny, nrow(sources)))

for (i in seq_along(sources$geometry)) { # i <- 1
  landscape$distance <- as.numeric(st_distance(landscape, sources[i,]))
  src.arr[, , i] <- exp_power(landscape$distance)
}

src.mat <- sum_third_dim(src.arr, sources$cones)

grd[, "density"] <- src.mat[1:length(src.mat)]
ras <- raster::rasterize(as(grd, "Spatial"), ras, field="density")
raster::writeRaster(ras, here("output","broervika","ExP.tif"))

raster::plot(log(ras), main = "log(Exponential Power)", col = viridis::viridis(n=255))
points(as(sources, "Spatial"))
points(as(traps, "Spatial"), pch=20, col="red")

rm(list = setdiff(ls(), c(freeze)))
```

```{r generalized Log-sech model}
freeze <- ls()
source(here("R","dispersal-functions.R"))

# From Bullock et al. 2017
a <- 3.4581
b <- 0.3988
logsech <- function(d) {
  (1/(pi^2*b*d^2))*((d/a)^(1/b)+(d/a)^(-1/b))^-1
}

src.arr <- array(dim = c(nx, ny, nrow(sources)))

for (i in seq_along(sources$geometry)) { # i <- 1
  landscape$distance <- as.numeric(st_distance(landscape, sources[i,]))
  src.arr[, , i] <- logsech(landscape$distance)
}

src.mat <- sum_third_dim(src.arr, sources$cones)

grd[, "density"] <- src.mat[1:length(src.mat)]
ras <- raster::rasterize(as(grd, "Spatial"), ras, field="density")
raster::writeRaster(ras, here("output","broervika","LogS.tif"))

raster::plot(log(ras), main = "log(Log-sech)", col = viridis::viridis(n=255))
points(as(sources, "Spatial"))
points(as(traps, "Spatial"), pch=20, col="red")

rm(list = setdiff(ls(), c(freeze)))
```

```{r validation}
files <- list.files(here("output","broervika"), pattern = "tif", full.names = TRUE)
stack.ras <- raster::stack(files)

trapdata <- read_csv(here("data","raw","seedtraps","seedtraps.csv")) %>% 
  add_column(adWALD = raster::extract(stack.ras$adWALD, as(traps, "Spatial"))) %>% 
  mutate(adWALD = adWALD*sum(seeds)/sum(adWALD)) %>% 
  add_column(aiWALD = raster::extract(stack.ras$aiWALD, as(traps, "Spatial"))) %>% 
  mutate(aiWALD = aiWALD*sum(seeds)/sum(aiWALD)) %>% 
  add_column(ExP = raster::extract(stack.ras$ExP, as(traps, "Spatial"))) %>% 
  mutate(ExP = ExP*sum(seeds)/sum(ExP)) %>% 
  add_column(LogS = raster::extract(stack.ras$LogS, as(traps, "Spatial"))) %>% 
  mutate(LogS = LogS*sum(seeds)/sum(LogS)) %>% 
  arrange(desc(seeds))

src.dist <- st_distance(traps, sources[st_nearest_feature(traps, sources), ], 
                        by_element = TRUE) %>% 
  as.numeric %>% 
  round
trapdata <- add_column(trapdata, src.dist, .before = "seeds")

long <- trapdata %>% 
  gather("adWALD", "aiWALD", "ExP", "LogS", key = "model", value = "predicted")

g <- ggplot(long, aes(seeds, predicted, color = model)) + 
  geom_point() +
  geom_abline(aes(slope=1, intercept=0)) +
  theme_bw()
g

g + coord_cartesian(xlim = c(0, 200), ylim = c(0, 400))

# Relationship between predicted and observed should be a line (of any slope and intercept). Therefore, examine the R-square of a linear model, or simply the Pearson correlation:
pairs(trapdata[,c("seeds", "adWALD", "aiWALD", "ExP", "LogS")])
cor(trapdata$adWALD, trapdata$seeds)
cor(trapdata$aiWALD, trapdata$seeds)
cor(trapdata$ExP, trapdata$seeds)
cor(trapdata$LogS, trapdata$seeds)

# However, the above values are strongly affected by the extremes of the distributions.
# Do boostrap analysis to reduce the leverage of individual observations:

n <- 1000
bootstrap <- tibble(adWALD = numeric(n), 
                    aiWALD = numeric(n),
                    ExP = numeric(n), 
                    LogS = numeric(n))
for (i in 1:n) {
  d <- trapdata %>% 
    sample_n(nrow(trapdata)/2, replace = TRUE) %>% 
    select(seeds, adWALD, aiWALD, ExP, LogS)
  bootstrap[i, ] <- cor(d)[1, 2:5]
}

df <- bootstrap %>% 
  mutate(index = 1:nrow(bootstrap)) %>% 
  gather(key = "model", value = "correlation", adWALD, aiWALD, ExP, LogS)

ggplot(df, aes(x = model, y = correlation)) +
  geom_line(aes(group = index), alpha = 0.2, colour = "darkgrey") +
  geom_boxplot() +
  theme_classic()

# Ordering traps by distance to nearest source:
ggplot(long, aes(src.dist, predicted - seeds, color = model)) +
  geom_point() +
  geom_abline(aes(slope=0, intercept=0)) +
  theme_bw() +
  labs(x = "distance to nearest seed source")
```

```{r sessionInfo}
sessionInfo()
```