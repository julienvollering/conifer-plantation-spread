---
title: "Dispersal model validation"
output: html_document 
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(here)
library(sf)
```

```{r wind Floro station, warning=FALSE}
windobs <- read_delim(here("data","raw","eKlima","obswind-stnr57710FLORO-20190604.txt"), 
                      delim = ";", na = "-9999", skip = 24) %>% 
  drop_na()
count(windobs, fDD)
count(windobs, fFF)
windobs <- filter(windobs, fDD == "OK" & fFF == "OK") %>% 
  select(-c("St.no", "fDD", "fFF"))

windobs %>% 
  group_by(Mnth) %>% 
  summarize(mean=mean(FF), sd=sd(FF))
```

```{r read seed sources}
sources <- read_csv(here("data","raw","seedtraps","seedsources.csv")) %>% 
  st_as_sf(coords = c(1:2), crs = 25832) # ETRS89 / UTM zone 32N
plot(sources["height"], key.pos = 4)
plot(sources["cones"], key.pos = 4)
hist(sources$cones)
```

```{r make grid geometry}
gridres <- 2
grd <- st_sf(st_make_grid(sources, cellsize = gridres, 
                          offset = floor(st_bbox(sources)[c("xmin", "ymin")])))
pts <- st_sf(st_make_grid(sources, cellsize = gridres,
                          offset = floor(st_bbox(sources)[c("xmin", "ymin")]),
                          what = "centers"))
bb <- st_bbox(grd)
nx <- unname((bb$xmax - bb$xmin)/gridres)
ny <- unname((bb$ymax - bb$ymin)/gridres)
paste(nx, "x", ny)
plot(grd[c(1,121:122),]) #features ordered SW to NE, by row
```

```{r add data to geometry}
# Note: grid cells with multiple seed sources are duplicated by joining sources to grid, and we assume dispersal from cell center by joining grd to pts.
src <- st_join(pts, st_join(grd, sources)) %>% 
  filter(cones > 0)
sum(duplicated(src$geometry))

landscape <- raster::raster(here("data","raw","seedtraps","lidar","vegheight.tif")) %>% 
  raster::extract(as(pts, "Spatial")) %>% 
  st_sf(geometry = st_geometry(pts)) 
colnames(landscape)[1] <- "vegheight"
landscape$vegheight[(is.na(landscape$vegheight))] <- 0 
plot(landscape)
```

```{r seed density}
sector.breaks <- seq(0, 360, by=20)
dispersal.season <- c(9:12,1:2) # after Harris, A. S. 1990.
terminal.velocity <- 0.94 # m/s, after Sandvik, H. 2012.
source(here("R","functions.R"))
source(here("R","SkarpaasShea_2007.R"))

src.arr <- array(data = NA, dim = c(nx, ny, nrow(src)), 
                 dimnames = list(x=seq(nx), y=seq(ny), src=seq(nrow(src))))

for (i in 50) { #seq_along(src$geometry)) { # i <- 50
  dX <- st_coordinates(src)[i,1] - st_coordinates(landscape)[,1]
  dY <- st_coordinates(src)[i,2] - st_coordinates(landscape)[,2]
  landscape <- mutate(landscape, angle = angle(dX, dY)) %>% # compass bearing FROM landscape TO source (matches wind direction DD)
    mutate(sector = cut(angle, sector.breaks, include.lowest = TRUE)) %>% 
    mutate(dist.to.src = as.numeric(st_distance(landscape, src[i,])))

  sec.arr <- array(data = NA, dim = c(nx, ny, length(levels(landscape$sector))), 
                 dimnames = list(x=seq(nx), y=seq(ny), sec=levels(landscape$sector)))
  
  for (j in seq_along(levels(landscape$sector))) { # j <- 1
    vegheight <- landscape %>% 
      filter(sector == levels(landscape$sector)[j]) %>% 
      pull(vegheight) %>% 
      mean()
    set.seed(42)
    wind <- windobs %>% 
      filter(Mnth %in% dispersal.season) %>%
      mutate(sector = cut(DD, sector.breaks, include.lowest = TRUE)) %>%
      filter(sector == levels(landscape$sector)[j]) %>%
      sample_n(100, replace = TRUE, weight = FF) %>% # assume probability of abscission is directly related to wind speed
      pull(FF)
    
    distances <- landscape$dist.to.src
    distances[landscape$sector != levels(landscape$sector)[j]] <- NA
    
    wind.arr <- array(data = NA, dim = c(nx, ny, length(wind)), 
                 dimnames = list(x=seq(nx), y=seq(ny), windspeed=wind))
    
    for (k in seq_along(wind)) { # k <- 1
      WALD <- function(x, 
                      H = pull(src[i,], "height"), 
                      Fm = terminal.velocity,
                      Um = wind[k], zm = 10, # measured 10 m above ground at station 
                      h = vegheight) {
        d <- calc_d(h)
        z0 <- calc_z0(h)
        ustar <- calc_ustar(Um, zm, d, z0)
        U <- calc_U(H, ustar, d, z0)
        sigma <- calc_sigma(z = H, d, ustar, U)
        nu <- calc_nu(H, U, Fm)
        lambda <- calc_lambda(H, sigma)
        statmod::dinvgauss(x, mean=nu, shape=lambda)
      }
      
      # Divisor below accounts for the fact that the WALD formulation was "dispersal DISTANCE kernel" (see eq. 15.3 in Nathan 2012). 
      # Essentially, far cells are reduced relative to close cells, because the distance kernel is spread over a wider sector at distance.
      wind.arr[, , k] <- WALD(distances) / (2*pi*distances)/(length(levels(landscape$sector)))
      
    }
    
    sec.arr[, , j] <- rowSums(wind.arr, dims = 2)
  }

  set.seed(42)
  secweight <- windobs %>% 
    filter(Mnth %in% dispersal.season) %>%
    mutate(sector = cut(DD, sector.breaks, include.lowest = TRUE)) %>%
    sample_n(1000, weight = FF) %>% 
    count(sector) %>% 
    mutate(normalized = n/sum(n))
  for (z in seq_along(levels(landscape$sector))) {
    sec.arr[, , z] <- sec.arr[, , z] * secweight$normalized[z]
  }

  src.arr[, , i] <- rowSums(sec.arr, na.rm = TRUE, dims = 2) # JV: dont forget cone weighting!
}      
      
fields::image.plot(src.arr[,,50])
```


```{r sessionInfo}
sessionInfo()
```