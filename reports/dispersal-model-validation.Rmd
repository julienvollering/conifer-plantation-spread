---
title: "Dispersal model validation"
output: html_document 
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(here)
library(sf)
```

```{r read seed sources and traps}
sources <- read_csv(here("data","raw","seedtraps","seedsources.csv")) %>% 
  st_as_sf(coords = c(1:2), crs = 25832) # ETRS89 / UTM zone 32N
plot(sources["height"], key.pos = 4)
plot(sources["cones"], key.pos = 4)
hist(sources$cones)

traps <- read_csv(here("data","raw","seedtraps","seedtraps.csv")) %>% 
  st_as_sf(coords = c(1:2), crs = 25832) # ETRS89 / UTM zone 32N
plot(traps["seeds"], key.pos = 4)
hist(traps$seeds)
```

```{r make grid geometry}
gridres <- 2
datageom <- c(st_geometry(sources), st_geometry(traps))
grd <- st_sf(st_make_grid(datageom, cellsize = gridres, 
                          offset = floor(st_bbox(datageom)[c("xmin", "ymin")])))
pts <- st_sf(st_make_grid(datageom, cellsize = gridres,
                          offset = floor(st_bbox(datageom)[c("xmin", "ymin")]),
                          what = "centers"))
bb <- st_bbox(grd)
nx <- unname((bb$xmax - bb$xmin)/gridres)
ny <- unname((bb$ymax - bb$ymin)/gridres)
paste(nx, "x", ny)
```

```{r add data to geometry}
landscape <- raster::raster(here("data","raw","seedtraps","lidar","vegheight.tif")) %>% 
  raster::extract(as(pts, "Spatial")) %>% 
  st_sf(geometry = st_geometry(pts)) 
colnames(landscape)[1] <- "vegheight"
landscape$vegheight[(is.na(landscape$vegheight))] <- 0 
plot(landscape)
```

```{r wind Floro station, warning=FALSE}
windobs <- read_delim(here("data","raw","eKlima","obswind-stnr57710FLORO-20190604.txt"), 
                      delim = ";", na = "-9999", skip = 24) %>% 
  drop_na()
count(windobs, fDD)
count(windobs, fFF)
windobs <- filter(windobs, fDD == "OK" & fFF == "OK") %>% 
  select(-c("St.no", "fDD", "fFF"))

windobs %>% 
  group_by(Mnth) %>% 
  summarize(mean=mean(FF), sd=sd(FF))
```

```{r abscission-dependent WALD model}
freeze <- ls()
source(here("R","functions.R"))
source(here("R","SkarpaasShea_2007.R"))

terminal.velocity <- 0.94 # m/s, after Sandvik, H. 2012.
sector.breaks <- seq(0, 360, by=10)
dispersal.season <- c(9:12,1:2) # after Harris, A. S. 1990.
windobs <- windobs %>% 
  filter(Mnth %in% dispersal.season) %>% 
  mutate(sector = cut(DD, sector.breaks, include.lowest = TRUE))

# Assume probability of abscission is directly related to wind speed
set.seed(42)
sectors360 <- tibble(sector = unique(cut(0:360, sector.breaks, include.lowest = TRUE))) %>% 
  add_column(weight = sample_frequency(among = windobs, of = quo(sector), weightedby = quo(FF)))
set.seed(42)
winds <- lapply(sectors360$sector, function(x) {
  filter(windobs, sector == x) %>% 
    sample_n(100, replace = TRUE, weight = FF) %>% 
    pull(FF)
})

pb <- txtProgressBar(0, nrow(sources), style = 3)

src.arr <- array(dim = c(nx, ny, nrow(sources)))

for (i in seq_along(sources$geometry)) { # i <- 1
  landscape$sector <- assign_sectors(to = landscape, around = sources[i, ], 
                            between = sector.breaks)
  landscape$distance <- as.numeric(st_distance(landscape, sources[i,]))
  src.sectors <- sectors360$sector[sectors360$sector %in% landscape$sector]
  
  sec.arr <- array(dim = c(nx, ny, length(src.sectors)))
  
  for (j in seq_along(src.sectors)) { # j <- 1

    vegheight <- landscape %>% 
      filter(sector == src.sectors[j]) %>% 
      pull(vegheight) %>% 
      mean()
    distances <- landscape$distance
    distances[landscape$sector != src.sectors[j]] <- NA
    
    wind.arr <- array(data = NA, dim = c(nx, ny, 100))
    
    for (k in 1:100) { # k <- 1
      WALD <- parameterize_WALD(H = pull(sources[i,], "height"), 
                                Fm = terminal.velocity,
                                Um = winds[[j]][k], zm = 10, # measured 10 m above ground at station 
                                h = vegheight)
      
      # Divisor below accounts for the fact that the WALD formulation used here is the "dispersal DISTANCE kernel" (see eq. 15.3 in Nathan 2012). Essentially, far cells are reduced relative to close cells, because the distance kernel is spread over a wider sector at distance.
      wind.arr[, , k] <- WALD(distances) / (2*pi*distances)/(length(nrow(sectors360)))
    }
    sec.arr[, , j] <- sum_third_dim(wind.arr)
  }
  src.arr[, , i] <- sum_third_dim(sec.arr, 
                                  sectors360$weight[which(sectors360$sector %in% src.sectors)])
  setTxtProgressBar(pb, i)
}      
close(pb)

saveRDS(src.arr, here("output","broervika","WALD-absdep_src-arr.rds"))      
# src.arr <- readRDS(here("output","broervika","WALD_src-arr.rds"))

src.mat <- sum_third_dim(src.arr, sources$cones)

WALD.grd <- grd
WALD.grd[, "density"] <- src.mat[1:length(src.mat)]
plot(WALD.grd)
plot(st_geometry(sources), pch=3, col="white", add=TRUE) # not working

WALD.ras <- raster::raster(nrows=ny, ncols=nx, 
                           xmn=st_bbox(grd)[1], xmx=st_bbox(grd)[3], 
                           ymn=st_bbox(grd)[2], ymx=st_bbox(grd)[4],
                           crs=st_crs(grd)$proj4string)
WALD.ras <- raster::rasterize(as(WALD.grd, "Spatial"), WALD.ras, field="density")
raster::writeRaster(WALD.ras, here("output","broervika","adWALD.tif"))
raster::plot(log(WALD.ras))
points(as(sources, "Spatial"))
points(as(traps, "Spatial"), pch=20, col="red")

rm(list = setdiff(ls(), c(freeze)))
```

```{r abscission-independent WALD model}
freeze <- ls()
source(here("R","functions.R"))
source(here("R","SkarpaasShea_2007.R"))

terminal.velocity <- 0.94 # m/s, after Sandvik, H. 2012.
sector.breaks <- seq(0, 360, by=10)
dispersal.season <- c(9:12,1:2) # after Harris, A. S. 1990.
windobs <- windobs %>% 
  filter(Mnth %in% dispersal.season) %>% 
  mutate(sector = cut(DD, sector.breaks, include.lowest = TRUE))

# Assume probability of abscission is UNRELATED to wind speed (constant)
set.seed(42)
sectors360 <- tibble(sector = unique(cut(0:360, sector.breaks, include.lowest = TRUE))) %>% 
  add_column(weight = sample_frequency(among = windobs, of = quo(sector), weightedby = NULL))
set.seed(42)
winds <- lapply(sectors360$sector, function(x) {
  filter(windobs, sector == x) %>% 
    # assume probability of abscission is directly related to wind speed
    sample_n(100, replace = TRUE, weight = NULL) %>% 
    pull(FF)
})

pb <- txtProgressBar(0, nrow(sources), style = 3)

src.arr <- array(dim = c(nx, ny, nrow(sources)))

for (i in seq_along(sources$geometry)) { # i <- 1
  landscape$sector <- assign_sectors(to = landscape, around = sources[i, ], 
                            between = sector.breaks)
  landscape$distance <- as.numeric(st_distance(landscape, sources[i,]))
  src.sectors <- sectors360$sector[sectors360$sector %in% landscape$sector]
  
  sec.arr <- array(dim = c(nx, ny, length(src.sectors)))
  
  for (j in seq_along(src.sectors)) { # j <- 1

    vegheight <- landscape %>% 
      filter(sector == src.sectors[j]) %>% 
      pull(vegheight) %>% 
      mean()
    distances <- landscape$distance
    distances[landscape$sector != src.sectors[j]] <- NA
    
    wind.arr <- array(data = NA, dim = c(nx, ny, 100))
    
    for (k in 1:100) { # k <- 1
      WALD <- parameterize_WALD(H = pull(sources[i,], "height"), 
                                Fm = terminal.velocity,
                                Um = winds[[j]][k], zm = 10, # measured 10 m above ground at station 
                                h = vegheight)
      
      # Divisor below accounts for the fact that the WALD formulation used here is the "dispersal DISTANCE kernel" (see eq. 15.3 in Nathan 2012). Essentially, far cells are reduced relative to close cells, because the distance kernel is spread over a wider sector at distance.
      wind.arr[, , k] <- WALD(distances) / (2*pi*distances)/(length(nrow(sectors360)))
    }
    sec.arr[, , j] <- sum_third_dim(wind.arr)
  }
  src.arr[, , i] <- sum_third_dim(sec.arr, 
                                  sectors360$weight[which(sectors360$sector %in% src.sectors)])
  setTxtProgressBar(pb, i)
}      
close(pb)

saveRDS(src.arr, here("output","broervika","WALD-absind_src-arr.rds"))      
# src.arr <- readRDS(here("output","broervika","WALD_src-arr.rds"))

src.mat <- sum_third_dim(src.arr, sources$cones)

WALD.grd <- grd
WALD.grd[, "density"] <- src.mat[1:length(src.mat)]
plot(WALD.grd)
plot(st_geometry(sources), pch=3, col="white", add=TRUE) # not working

WALD.ras <- raster::raster(nrows=ny, ncols=nx, 
                           xmn=st_bbox(grd)[1], xmx=st_bbox(grd)[3], 
                           ymn=st_bbox(grd)[2], ymx=st_bbox(grd)[4],
                           crs=st_crs(grd)$proj4string)
WALD.ras <- raster::rasterize(as(WALD.grd, "Spatial"), WALD.ras, field="density")
raster::writeRaster(WALD.ras, here("output","broervika","aiWALD.tif"))
raster::plot(log(WALD.ras))
points(as(sources, "Spatial"))
points(as(traps, "Spatial"), pch=20, col="red")

rm(list = setdiff(ls(), c(freeze)))
```

```{r generalized Exponential Power model}
freeze <- ls()
source(here("R","functions.R"))

# From Bullock et al. 2017
a <- 2.7825
b <- 0.8346
exp_power <- function(d) {
  b*(2*pi*a^2*gamma(2/b))^-1*exp(-(d^b/a^b))
}

src.arr <- array(dim = c(nx, ny, nrow(sources)))

for (i in seq_along(sources$geometry)) { # i <- 1
  landscape$distance <- as.numeric(st_distance(landscape, sources[i,]))
  src.arr[, , i] <- exp_power(landscape$distance)
}

src.mat <- sum_third_dim(src.arr, sources$cones)

Exppow.grd <- grd
Exppow.grd[, "density"] <- src.mat[1:length(src.mat)]
plot(Exppow.grd)
plot(st_geometry(sources), pch=3, col="white", add=TRUE) # not working

Exppow.ras <- raster::raster(nrows=ny, ncols=nx, 
                           xmn=st_bbox(grd)[1], xmx=st_bbox(grd)[3], 
                           ymn=st_bbox(grd)[2], ymx=st_bbox(grd)[4],
                           crs=st_crs(grd)$proj4string)
Exppow.ras <- raster::rasterize(as(Exppow.grd, "Spatial"), Exppow.ras, field="density")
raster::writeRaster(Exppow.ras, here("output","broervika","EP.tif"))
raster::plot(log(Exppow.ras))
points(as(sources, "Spatial"))
points(as(traps, "Spatial"), pch=20, col="red")

rm(list = setdiff(ls(), c(freeze)))
```


```{r validation}
files <- list.files(here("output","broervika"), pattern = "tif", full.names = TRUE)
stack.ras <- raster::stack(files)

trapdata <- read_csv(here("data","raw","seedtraps","seedtraps.csv")) %>% 
  add_column(adWALD = raster::extract(stack.ras$adWALD, as(traps, "Spatial"))) %>% 
  mutate(adWALD = adWALD*sum(seeds)/sum(adWALD)) %>% 
  add_column(aiWALD = raster::extract(stack.ras$aiWALD, as(traps, "Spatial"))) %>% 
  mutate(aiWALD = aiWALD*sum(seeds)/sum(aiWALD)) %>% 
  add_column(EP = raster::extract(stack.ras$EP, as(traps, "Spatial"))) %>% 
  mutate(EP = EP*sum(seeds)/sum(EP)) %>% 
  arrange(desc(seeds))

trapdata <- add_column(trapdata, nearest.src = sapply(st_geometry(traps), function(x) {
  ind <- st_nearest_feature(x, sources)
  st_distance(x, st_geometry(sources)[[ind]]) %>% 
    round()
}), .before = "seeds")

long <- trapdata %>% 
  gather("adWALD", "aiWALD", "EP", key = "model", value = "predicted")

g <- ggplot(long, aes(seeds, predicted, color = model)) + 
  geom_point() +
  geom_abline(aes(slope=1, intercept=0)) +
  theme_bw()
g

g + coord_cartesian(xlim = c(0, 200), ylim = c(0,250))

g + scale_x_log10() + scale_y_log10()

ggplot(long, aes(nearest.src, predicted - seeds, color = model)) +
  geom_point() +
  geom_abline(aes(slope=0, intercept=0)) +
  theme_bw()

cor(trapdata$seeds, trapdata$adWALD, method = "spearman")
cor(trapdata$seeds, trapdata$aiWALD, method = "spearman")
cor(trapdata$seeds, trapdata$EP, method = "spearman")

?glm
glm(seeds ~ adWALD - 1, family = poisson, trapdata)
glm(seeds ~ aiWALD - 1, family = poisson, trapdata)
glm(seeds ~ EP - 1, family = poisson, trapdata)

#subset of data by nearest.src?
```

```{r sessionInfo}
sessionInfo()
```